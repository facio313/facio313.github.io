* Data Migration (데이터 이관)

* 메타데이터 관리 시스템

* 메타 솔루션

* 역공학

* Entity의 분류
Key Entity - Main Entity - Action Entity - 목적성 Entity
- TO-BE 전락&데이터 요구사항, 모델링 원칙&표준, 데이터 표준, 데이터 이관 고려
- Key Entity, Main Entity : 반드시 설계 규약이나 규칙에 따라 만들어야 함
- 목정성 Entity : 저장소를 얼마나 효율적으로 불일치성(데이터 이상)을 해소할지와는 관계 없이 만드는 Entity
ㄴ 통계, 임시, 작업성

* 데이터 모델링 전략(데이터 집합에 관해)
1) 정체성(독립성) : 고유 성격 유지, 지나친 속성 중복으로 정체성을 희석시키면 안 됨(조인해서 써라~) <-> 반정규화(성능)
2) 일관성(정합성) : 하나의 정보는 한 곳에서 관리(동일 정보 동일 값 유지), 중복 최소화 -> 효율적 접근
3) 통합성 : 유사 성격의 정보는 통합하여 관리, 업무 프로세스가 데이터는 비즈니스 유사성 기준으로 통합하여 관리
4) 무결성★ Integrity : 식별자 상속 명확히, 타 데이터 집합 참조 시 결함 없어야 함 => 꼭 고려해야 함
    - DBMS 안에서 통제 가능
        ㄴ 개체무결성★ : 유일식별자, PK
        ㄴ 참조무결성 : FK(예전에는 10~15% 정도 손실 - 직렬, 요즘에는 ssd 병렬이라 없다시피 함), 관련있는 값, 부모자식(cascade 옵션)
        ㄴ 도메인무결성 : CHECK(Y,N or Between), 특정 값만 써야 하는 경우(ex 여부, 성별 등), 정해놓은 거 빼고는 오류가 남
    - APP 로직에서 통제
        ㄴ 사용자정의무결성
        
5) 구조의 확장성(유연성) : 다양한 비즈니스적 미래 구조에 대응, 고려할 수 있어야 함

* 논리모델
- 주제영역 : 업무에서 관리하고자 하는 Entity 그룹, ERD의 관리 단위 
- Entity : 업무 수행을 위해 데이터로 관리하는 개체들(사람, 사물, 장소, 사건 등)
- 식별자(UID) : Entity 내에서 각각의 인스턴스를 유일하게 구분할 수 있는 단일 속성 또는 속성 그룹
- 속성(Attribute) : Entity 정보 관리의 데이터 항목, 더 이상 분리할 수 없는 최소한의 데이터 보관 단위
- 관계(Relationship) : Entity 간의 연관성

* Entity
- 업무 수행을 위한 관계 대상, 기록 관리를 요구하는 추상적 or 구체적 사물 종류 의미
- 사람(사용자, 관리자 등), 장소(시군구 등), 개념, 사물, 이벤트
ex) 자료구조, 데이터베이스, 프로그래밍 등 -> 과목 / 컴퓨터공학과, 경영정보학과, 국어교육학과 등 -> 학과 / 학생별 수강 신청 내역 -> 수강 등록(학생과 과목)
ex) 사원 - 부서 => 사원 -다-인사(관계)-다- 부서
1) 업무에서 필요하고 관리하고자 하는 정보
2) 식별자에 의해 유일하게 구별할 수 있어야 함
3) 일반적으로 다른 엔티티와 관계가 있음
4) 최소 1개 이상의 속성으로 구성해야 함(이론적으로는 두 개 이상... 속성이 두 개 이상이 아니면 딱히 의미가 없음. 파일로 관리해도 됨, 모델로서는 의미 없음)
명명규칙 : 1.국어사전 2.업무 / 단수명사 / 축약 / DBMS 상에서 테이블명(128byte,), 컬럼(128byte) - 원래는 30byte 정도, 한글은 256, 512 byte까지도?... / 하나만 명확하게 / 공백, 공란X 그냥 언더바 / 처리, 정보, 목록, 등록, 원장, 현황 등의 단어는 불필요함 ex) 사용자정보
- Entity의 유형(T, H, 등)
- Entity는 속성을 고려하여 통합하여 고려함, 안 그럴 때도 있음
    ㄴ 구조가 비슷한 경우, 동일 엔티티 증가가 빈번 예상 등
    ㄴ 통합하면 성능이 좋아짐(<-> union all)
    ㄴ 주의점 : 성능저하, 데이터 정체성 희석, 다른 유형 데이터 통합, 데이터 무결성 저하, 데잍 이관 고려
- Entity 통합 대상
    ㄴ 데이터 성격 유사
    ㄴ 역할 관리
    ㄴ 대칭적 업무 의미
    ㄴ 베타 관계 수행
    ㄴ 성능 향상 위한 반정규화
    ㄴ 1:1 Entity 관계 성릭 시

* ISP, ISMP -> 컨설팅 영역
ISP(Information strategy Plan) : 정보화전략계획
ㄴ 비즈니스 부분 : BPR(Bussiness Process Restruction)
ISMP(Information System Master Plan) : 정보화체계마스터플랜
ㄴ Process Integrity : 개별 ~를 어떻게 처리할 것인가??

connected by recursive?

한빛미디어 이춘식 기술사 데이터베이스 설계와 구축
엔코아 데이터 아키텍쳐 솔루션 -> 요거 함 보면 됨
위즈넘마인드 김기창 대표 관계형 데이터모델링 프리미엄 가이드, 관계형 데이터모델링 노트, 데이터모델링 강의, 데이터모델 리소스북 1 -> 요것도 보면 좋고
C.J.DATE Database Systems
종속함수론?

--------------------------------------------------------------------------------------------------------------------------

1. 데이터베이스 진흥원
- DAP(Data Architect Professional Guide) : 모델링, 표준화, DB
- SQLP : SQL 전문가 / P가 붙은 건 어려워~
- SQLD : 필기만 보는 것

* Supertype - Subtype(Extended E-R Model)
- Supertype : Subtype의 공통 속성을 관리하는 Entity, 1:1 관계인 상위 Entity, 부모 Entity는 아님 ex) 직무구분코드
* Exclusive OR
* Barker 표기법

* 식별자, PK가 만들어지는 조건
- PK 중복 시 객체 무결성을 위해 어떻게 하든 유일하게 만들어줘야 함, 취사 선택을 하든, 비고란을 만들든
- 식별자 선정 조건
    1) 안전성 : 일만 만들어지고 바뀌면 안 됨(성능도 문제)
    2) 최소성 : 가급적 하나, 많으면 두 세 개 정도(성능도 문제)
    3) 유일성 : 객체?개체? 무결성
    4) 활용성 : 인조식별자를 대체키로 만들어주면 되는데 무슨 말인지 모르겠엉
- 순서(내부 옵티마이저가 인덱스 순서대로 접근함) / 부모엔티티 상속 받은 자식 엔티티의 외래키는 부모 엔티티의 식별자 순서와 동일하게!(성능 문제)
- 식별자 제약사항 : 가급적 CHAR 타입 사용X, but 쓰라고 한다면 써야지..로직이 정확하지 않으면 varchar가 나음, 성능상 큰 차이는 없음
    - 쓸 때 없는 거 넣지 말고 최소화!
    - 암호화 대상 속성은 쓰지 않기

* 인조식별자
- 참조하는 것이 능사가 아님
- 인조식별자 만들어서 쓰는 것도 방법
- 속성으로 내리고 식별자를 그냥 새로 만드는 게 더 편할 때도 많음
- (bcnf : 정규화하면서 쓸 데 없는 거 빼라!) 라는 것도 인조식별자는 일맥상통
- 유형별 적용 기준 : 번호
- 시퀀스 -> 메모리에 한 번 넣어놓고 중간에 없어지면 결번이 생김,,,일련번호(시퀀스로 쓰는 것)를 pk로 쓰진 마라

* 식별자 참조
- 접수 - 처리 - 완료
=> 따로 테이블 만들지 말고!! 데이터 구조에는 흐름이 없음(프로세스의 표시가 아님)
=> 상속이 아니고 참조임(reference)
- 직접종속참조 vs 간접종속참조

=> 중요함
* 식별자 참조 시 단점
* 식별자 참조 시 주의 사항

* 속성(Attirbute)
- Entity에서 관리하는 데이터 항목으로서 더 이상 분해할 수 없는 최소의 데이터 저장 단위
- instance or tuple의 칸 하나 하나락 생각하면 됨
- 속성 하나 하나는 다 중요하고 필요한 거. 필요한 게 없다면 뭣하러 저장하냐!
1) 기본 속성
2) 관계 속성
3) 추출 속성 : 반정규화와 관련됨
4) 시스템 속성
, 4는 쿼리로 가능
- 동일 업무라도 발동 안 될 수 있음 

iso 표준 : datetime, date
구조물의 범위 x 구조물범위 o, 약어 되도록 안 쓰고, 말이 길어진다면 복합어처리
동음이의어 사용 x
데이터 표준화 가이드 참조

* 속성 병렬/직렬 설계 기준
항상 그런 것은 아님
- 직렬 : n:n관계 ex)건설사?
- 병렬 : 1:n ex)코드가 다 필요하지 않을 때, 변동이 많을 때
=> 얘네다시 정리해야 할 듯

* 관계(Relationship)
- 2개 이상의 Entity 사이에 존재하는 상호간의 연관성으로, 업무 규칙에 의해 관계선으로 표현함
이어진------ 직접종속
끊어진------ 간접종속
JOIN하는 데에는 아무 문제 없음
원래는 관계동사를 명시하게 되어 있음(하지만 가독성을 위해 새략함)
직관적이면 관계명 안 써도 됨
자식(하위) Entity + 역할명 + 부모(상위) Entity
사원 - 계좌관리사원 - 계좌(계좌관리사원번호)

* Cardinality(관계성)
1 : 1 => 10% 별도로 둘 수도 있지만 통합하는 게 원칙(블록체이닝...성능문제... 여러 가지 고려하기)
1 : n => 80%
n : n => 10% 상품 고객 => 주문
발주한다 -|----|< 발주된다
* Optionality
Optional or Mandantory
0인지 아닌지 표현

* 관계 타입
식별관계 : 실선
비식별관계 : 점선, 참조

* recursive
* 엑사데이터?

--------------------------------------------------------------------------------------------------------------------------

* 배타적 관계(Exclusive Relation or Arc Relation)
주식종목   ...->
                거래내역  : 어쩔 땐 주식종목 키가 올 수도 있고 어쩔 땐 채권종목 키가 올 수도 있음
채권종목   ...->

그래서 다음과 같이 만듬

거래종목(종목번호 - 종목코드) -1-n-> 거래내역(종목번호, 거래일시 - ~)

* 순환 관계(Recursive) 관계
자기 참조를 뜻하는 관계(=재귀관계)
사장, 재무부, 총괄기획부, ... => 부서(부서코드) - 부서(상위,관리 부서코드, 부서명은 동일하게)
오라클에는 recursive query가 있음, 다른 곳에서는 self join 써야 함
1) start with 부서코드, connect by ~ prior
2) scalar view (scalar query : select절에 사용하는 subquery)

관계선에 너무 맹목적이지 않아도 됨
논리 모델 단계에서 주제영역과, 개념 모델에서 핵심 Entity를 정확히 하는 게 제일 중요함

* BOM 관계
재귀 관계과 m:m인 순환 관계

* 잘못 표현한 관계

테이블을 업무프로세스로 만들지 말기
입력 -< 처리 -< 저장

* 정규화
정속함수론(집합론) FUNCITON {A{B, C}}
1정규화 : 속성 분리(속성의 원자화) => 반복 속성 그룹을 제거함(화면에서도 안 하는 곳이 있음)
    - 코드 복잡도, 프로그램 복잡도, DB 성능 문제가 있을 수 있음
2정규화 : 완전 부분종속을 해소함 -> 완전 종속 구현
3정규화 : 이행 종속 제거
보이스-코드 정규화 : 결정자 종속 제거
---------------------------------
4정규화 : 다가 종속 제거
5정규화 : 결합 종속, 조인 종속

* 1차 정규화(1NF : first normal form)
복수의 속성 값을 갖는 속성 분리

* 2차 정규화
완전 함수 종속적인 데이터 구조 만들기
종속이 식별자에 있음

* 3차 정규화
종속이 일반속성에 있음

여기까지 하면 정규화가 거의 다 끝남,,식별자가 복잡한 경우에만 bcnf를 함, 비즈니스 룰이 복잡해서 해당되는 Entity를 좀더 분해를 할 때나
그래서 bcnf는 원래 3정규화로 명명지으려 했으나 논문발표가 늦어져 그냥 bcnf로...강력하다고 함..
* 보이스-코드 정규화(bcnf)
후보 식별자간 중속 제거
후보 식별자 : 키로 만들 수 있는 여러 후보들, 그 중에서 가장 적은 수로 데이터 간 유일성을 확보해줄 수 있는 것을 실제 식별자로 고름
ㄴ 여러 가지가 있을 때 중복되는 것을 제거하는 것
ㄴ 이때 쓸데없이 어쩌고 더 해버림
님픔 -> 부품,부품번호 -> 납품번호, 부품번호 - 예시는 교재보기
- 3정규화를 한 번 해놓고 하는 것
------------일반적으로 정규화 완료------------

* 이력관리
- 발생이력
- 진행이력
- 변경이력
으로 구분됨. but 명확하게 구분 안 될 수도 있음
- 시점이력(점이력) : 시점에 따라 바뀌는 것을 하나 하나 쌓아서 저장 -> 데이터 추가/변경/삭제, dml transation
- 선분이력 : 기간을 다 관리할 수 있도록?? 발생 시점부터 종료 시점까지 -> 환율, 엘리베이터 층수
    ㄴ 종료 시점을 비워놔도 11g부터는 성능 문제가 없다지만 관행상 폐구간을 넣어서 씀(?), 현재상태를 주로 조회하는 경우 종료시점을 식별자로!(between)
이력관리유형
- ROW 중심(인스턴스 레벨) - 저장공간낭비가 있지만 요즘에서는 의미가 없고, 쿼리하는 데에 더 편하기도 함
- COLUMN 중심(속성 레벨)
- SUBJECT 중심(속성 그룹 레벨) - 양쪽 꺼를 합침, 자식 이력 테이블을 많이 만듬(고객 - 주소변경이력, 전화번호변경이력, 비밀번호변경이력)

* 이력 Entity의 식별자 선정
이력 Entity 의 식별자 유형은 세 가지로 나뉨
1) 유효시작일자를 식별자에 포함
2) 유효종료일자를 식별자에 포함
3) 변경일련번호/이력일련번호 또는 변경일시를 식별자에 포함

ansi vs oracle join -> 성능 문제 주장도 있고, 주로는 이식성 때문에 그럼(티베로는 오라클 써도 괜츈)
ㄴ 성능 차이 없대;; 쓰는 방식에서 오라클에서 구현하지 못한 것이 full outer join (양쪽 기준에 +를 못 넣어주니까..)

* 이력 테이블은 update가 없음! 데이터 기준 테이블은 최초 insert, 두 번째부터는 update

* 시스템 속성 데이터 처리 기준
------------------------------------------------------------------------------------------------------------

* 채번
이력, 상세 테이블에서 반복되는 정보들을 serial하게 만들어줄 때(직렬화)
세 가지 방법이 있음(요건에 따라 다름)
1) 채번 테이블 : 도서관 시스템(중복 에러x, 순차 입력 가능), 잠금 현상 유발하는데 거의 없긴 함
    transaction이 많으면 동시성 제어를 해야 함(4단계 serialize)
    select ~~~ for update : 동시성 제어를 위한 추가적인 옵션 부분
    transaction이 많지 않으면 채번 테이블을 쓰는데, 동시성 제어가 잘되어 있으면 쓰기도 함
2) MAX + 1 : 빠른 성능, 순차 입력 가능,
    중복 에러 가능
    transation이 많지 않으면 사용함
    중복 에러에 대처 가능한 보완 처리를 해놨다면
3) Sequence : 번호 발생 Object, cache에 들어가는 건 메모리에 있지만 메모리는 휘발성, 껐다 키면 사라짐, 번호가 중간에 있던 것이 떠버리는 경우가 생김
    transation이 아주아주 많을 때(은행, 자동 데이터 발생 후 계속 쏴줘야 하는 것들)
    상세정보를 빨리 쌓아야 할 때 씀
    테이블마다 별도로 둘 수 있고, 명 지정 후 nextval을 불러다 바로바로 불러서 해도 됨.
    결번이 떴다 하면 다시 만들어서 refresh하면 됨 -> 결번 자체가 없을 수도 있음
부하가 없다 하면 그냥 Sequence 쓰는 게 편함
1, 2, 3의 차이 : 중간 결번
결번 가능, 그냥 순차 -> Sequence 상관 없음
MARC : 미국 의회 도서관에서 만든 텍스트 데이터, KORMARC(서지정보), 이거 등록할 때 번호에 결번이 있으면 안 됨. 채번 테이블을 별도로 만들어 사용함

* Not Null, Default
기본적으로 테이블에서 빠지면 안 되는 애들
식별자/PK는 무조건 NN
코드 같은 것, 기존에 Null로 쓰는 곳도 많은데, 원칙적으로 코드에서는 Null이 없음(여집합이 원래 있으면 안 되지만 ), 정의 안 함, 사용 안 함 ~~
원칙적으로는 - 하나 넣어서 쓰고 다른 걸로 할 수 있으면 00 미정 99 기타 등으로 쓰는 걸 권장
- 모델의 모호성 제거
부서코드가 null이면 부서가 배정되지 않은 사원이 생길 수도 있음. 그래서 미배정부서 코드로 만들고 부서코드를 not null로 만들어 반드시 들어가게끔!
Not Null과 Default는 별개지만 Default 옵션을 해놨는데 Not Null도 이상함. 물론 안 그럴 수도 있지만 굳이 필요한가라는 제약사항?
둘을 쌍으로 쓸 수 있게끔 하는 것으 권장함
nvl로 좌변을 변환하게 하면 FTS(Full Table Scan)임. 데이터가 너무 많으면 해당 트랜잭션이 너무 오래 걸려셔 타임아웃 걸릴 수도 있음.

개체무결성 pk
참조무결성 fk 성능 문제가 생기면 -> 사용자 정의 무결성 but fk 써라~
도메인무결성 체크 옵션
체크옵션

nvl 사용 시 or null 찾는 것을 사용 시
outer 조인 보다는 inner 조인을 사용해라...

Null값이 있을 때의 문제성 해소
일자성 속성('00000101' ~ '99991231')
코드성 속성(통합코드, 개별코드)
원래 데이터는 삭제하는 게 아니야...로그성...삭제여부로 관리해야 함
데이터를 삭제하게 되면 인덱스가 중간중간 끊겨서 저하가 됨
인덱스는 줄어드는 게 아니라 자리를 차지하게 됨
이때는 리빌드 인덱스 해야 함
그래서 굳이 데이터를 삭제하지 말고 플래그 값을 부여해라~
숫자형 속성(0)
pk는 default를 지정하지 않음
시스템 공통 속성 중 최초등록일시, 최종변경일시는 default로 sysdate를 지정함(형변화를 할 수도 있고, 공공에서는 date타입으로 넣음)

date도 내부적으로 길이를 가져감. 기본적으로 7바이트! 내부적으로
char, varchar에서 길이가 같으면(7로 정했을 때), char는 7바이트 varchar는 시스템 내부에서는 8바이트(보이지는 않음! 7바이트에서 앞에 플래그?가 하나 있음)
number(numeric) number(p,s) precision, scale는 38자리까지 표현하는 걸 22바이트로 함. 
number로 아무 것도 안 쓰고 표현하면 -> 실제론 number(38, 여러가지) =/= number(38) / 소숫점 맘대로 / 공공데이터 표준이 잘못되어 있음

* 오라클 내부 기준 책

* 논리모델이 끝나면 모델링이 그냥 끝난 것, 일단 그냥 만들어놓기

* 물리모델은 그냥 DB에 넣는 거, 테이블을 나눌 것인지, 안에서 파티셔닝할 것인지

* 원래 long데이터는 lob데이터로 바꿔서 써야지...테이블도 따로 나눠야 함..
long, raw, longraw
clob, blob : 캐릭터냐 머냐였는데.. 4기가까지 지원함
long은 deprecated됨

오라클 깔 때 블록 사이즈 (4k 8k 16k 등등) 정함 -> 테이블에서 인스턴스 하나 만들어지는 게 블록 사이즈라고 생각하면 됨
데이터 100개를 불러왔다 = 블록 100개를 읽었다.
row chainning
block migration

내부 파티셔닝 3가지가 있음

* 슈퍼타입-서브타입 통합 분리
논리 -> 물리 시 트랜잭션 패턴 및 데이터야에 따라 통합/분리 검토해야 함
데이터가 소량일 때는 성능 영향X, 유연성을 고려하여 1:1관계 유지하는 것이 바람직함, 소량이라면 테이블 하나로 전체를 묶는 것도 괜찮음
개별 테이블 <-> 슈퍼타입+서브타입별 데이터 통합 <-> 전체 하나로 통합

원래는 포스트잇으로 했었음....그러고 툴로 함

* 반정규화(역정규화 denormalization)
처음에는 정규화(중복제거)하고 나중에 성능을 위해 반정규화해야 함
논리모델링 단계가 아니라 물리모델링 단계임
물리테이블에서 하는데, 원래는 정합성이 application단에서 이루어져야 함.
기준 : 무결성이 우선? vs 단순화와 성능 우선? => 그렇다기보다는 먼저 해놓고 보는 것
1. 중요성 2. 성능 3. 관리용이성 4. 개발 편의성
테이블 반정규화 방법
1. 테이블 통합
    1) 1:1관계 테이블 통합
    2) 1:M관계 테이블 통합
    3) 슈퍼/서브타입 테이블 통합
2. 테이블 분할
    1) 수직 분할
    2) 수평 분할
3. 테이블 추가
    1) 복제 테이블 추가
    2) 통계 테이블 추가
    3) 이력 테이블 추가
    4) 부분 테이블 추가
컬럼 반정규화
1. 중복 컬럼 추가
2. 파생 컬럼 추가
3. 이력 테이블 컬럼 추가
4. 응용 시스템 오작동 방지를 위한 컬럼 추가

데이터 중심 관점 개발

dbms의 내부 구조 설명을 봐야 성능적인 측면을 알 수 있음 -> sql tunning까지도 갈 수 있음
톰 카이트가 쓴 '전문가를 위한 오라클 데이터베이스 아키텍처' (ask tom : tom kyte)
엑시엄 책 : 오라클 실전 튜닝, 디비안(조시형) 책 : 오라클 성능 고도화 원리와 해법
한빛미디어 : 개발자를 위한 아키텍트

da# erwin exerd
한국 데이터베이스 진흥원 - 그곳의 교육기관 : 데이터온에어(여기에 자료가 매우 많음. 오래되긴 했는데...)
엔코아 : en-core.com 여기서 만든 솔루션인 DA# 5.0 일반용 써보기, 기업용은 한 달밖에...일반용은 제약사항 있음..테이블 만드는 거 100개? 컬럼 수도 제한? 어떻게 그리는지
    논리모델은 이걸로 하는 게 조음, 빨간펜(모델링 연습문제)

rac가 머임? real application cluster
데이터베이스 분산 시스템
오라클 말고도 다 되지만 그 수준이 다름
WAS도 여러 개로 분리하듯 DB도 여러 대로 분리함
각각으로 transation을 분리함(접속 세션을 분리)
각각의 DB를 따로따로 만들어놓고 공통의 DB를 연결시켜놔서 마치 하나로 쓰는 것처럼 느끼게 함(하나로 묶는 게 clustering)
데이터베이스 병렬 분산 처리 시스템
병렬 분산 방식
1. A : Active B : Standby(replication) C : Standby(replication)
-> A가 fail일 때 고칠 때까지 Standby를 Active로 바꿈
=> 고가용성(HA High Ability) 요건 다 됨
2. Active - Active는 oracle rac, ibm db2, tibero tac(오라클6 때인가 소스 깐 거 그대로 빼낌, 엔진문제가 근본적)
-> 다 Active로 돌아가는 상태
-> fail이 나면 session을 다른 곳으로 chainning 시켜줌
- Oracle RAC의 경우
    : DB 하나 하나를 Instance(데이터베이스 안 전역변수)나 Node라고도 함 - 이 하나 하나가 GLOBAL DBNAME으로 묶이고 개별 SID1~SIDn으로 이름지어짐
    : 공용데이터 저장소에 광케이블로 붙음. 실제로 붙을 때 각각 개별로 접속할 수 있음
    : 모든 테이블은 공용데이터 저장소에 만들어지고 각 개별 DB가 세션을 나눠짐


    marc -> mods, xmlmarc

graph DB - 관계형DB의 제약사항을 뛰어넘어보자
xgeometry도 내부적으로 clob으로 처리~

오라클 hint!!!잘 쓰면 빠름 parallel
select /*+ parallel */
insert /*+ parallel */
insert /*+ append */ -> REDO LOG를 거치치 않아서 빠름
sql loadder /*+ append */

buffer pool, sga, process(LGWR -> REDO LOG), pga
트랜잭션 탈 때는 반드시 REDO LOG 써야 하는데
최초의 데이터 대량으로 적재할 때는 굳이 필요 없어..
그래서 /*+ append */
=> KAIS에서는 지점번호 쓸 때.. 함 씀
HINT는 정합성을 헤치지 않는 선에서 씀, OPTIMIZER에서 쓸 때 안 맞는다 하면 무시함, 오라클 내부 통계정보가 부정확해서 될 때도 있고, 안 될 때도 있고.
JOB, SCHEDULAR....JOB에는 부하가 많고 초기버전이라.. TRIGGER도 쓰지 마! 어디서 오류가 났는지 로그가 안 남음
어디서는 procedure도 돌리지 말고 서버단에서 다 처리해라~~
정기적으로 통계정보를 돌려줘야 함
analyze 명령어 오래걸림...쓰지 말구
dbms_stat.get_stat를 하면 퍼센트를 샘플링할 수 있음 default는 10%
실행계획 고정시킨 것 - DB 이관 시 통계정보 이관

maxgaze, ap서버 모니터링

인덱스는 데이터 자체가 아님. 데이터가 아닌 이상 날렸다가 새로 만들어도 됨.
인덱스 드랍하고 새로 만들어도 됨.
다 툴로 해야 됨..일일이 하기보다는..
토드가 머야? 툴이래...오렌지?....테이블리빌딩도 있대...내부적으로 컬럼 순서 바꾸는 것
생산적인 문제 때문에 툴을 써야 함