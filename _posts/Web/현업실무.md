1.19
Single Page Application
CSR(Client Side Render) > SSR(Server Side Render)

Controller Serivce Mapper SQL ajax

벨리온 소프트
1.28
DB설계
화면ui분석
현업vs학원 : 하고 싶은 주체가 다름 = 나 vs 발주자(외부요청)
외부요청의 특징적인 부분
- 화면 pdf 출력 가능하게 해주세요~(요구사항)
- 레드마인 실제로도 많이 씀
- 첨부파일 머라고 한 거임??
- 자바 심상원(대법원 인터넷 등기소 함 봐봐)

- 주민번호를 db에 그대로 담으면 안 됨(암호화해서 담아야 함)
- 개인정보보호법 관련
- 재동의 받는 것(로그인할 때 받는 것 -> 안 받으면 어쩔 거냐..동의 기간 지나면 막아야 함)
- 휴면계쩡(sql스케쥴러, framework스케쥴러)

생각한 기능을 구체화하는 게 어렵다
db설계

정처기 공부해라..
세션 클러스터링
라운드 로빈 스케쥴링 알고리즘

os 안에서 돌아가는 톰캣이 갖는 server.xml에 context path="/" "act"
톰캣에 돌아가는 project1, project2 이런 거 context라 함
context => container
project 간 session 공유가 됨 (이걸 세션 클러스터링) - context 이중화?
근데 os가 멈추면 톰캣도 멈추면서 procject가 멈춤...
이때 os를 두 개 만들고 각 os에 서버를 두고 각각 소스를 보냄(서버 이중화)
project가 근데 같은 곳을 바라봐야 함..
이중화 관련 문제가 있음

1. 겸손(계속 공부)
2. 자기가 못하는 거 열심히(못하는 거 피해가지 말고)
3. pl argu할 정도론 하지 마..
4. 자기의 메인 기능이 먼지
5. 자기가 하고 싶은거 뭔지
6. 뭐에서 pl 말을 들어야 한다고?...
7. 팀끼리 공유, 경쟁

db는 사람마다, 선생님마다 다름
- 내꺼가 틀렸단 생각 말고, 남의 것도 틀렸단 생각 말기
- 화면 만드는 데에 지장이 없는지만 생각하기
- 물어봤는데 답변을 못하고, 화면상 정의하지 못한 건 틀린 것

inner join의 기줌
화살표의 종착지가 어디냐에 따라 다름
lprod(a개) prod(b개) buyprod
        cart(c개)   member(b개)
lprod -< prod

outer join
- left
- right
각 기준으로 데이터가 몇 개 나오나

T1      T2
1       10
2       2
3       1
4       0
5       0
inner join 13개
outer join
- left : 15개
- right : 13개
ansi outer join


* right는 속도 문제 있음 -> inner join 쓰세요~

---|-----oK--- 의미
   1      N


테이블마다 동일한 건 동일하게 이름을 검 -> 그래서 원래는 별칭을 줘야 함
select b.prod_id, b.prod_name, a.cart_qty, (b.prod_price * a.cart_qty) as sum_
from cart a, prod b
where a.cart_prod = b.prod_id

cart a inner join prod b on (a.cart_prod = b.prod_id)

기준관리 테이블 : prod 계속 현행화되는 데이터(데이터 시점 : 현재)
이력관리 테이블 : cart 데이터가 계속 생성되는 것(데이터 시점 : 당시)

cart_price가 있어야 함

prod_price 현재의 가격
cart_price 판매 당시의 가격

    민원신청        ->      검토            ->      완료저장소(대장)
-공장1(김은대)      ->      공장1(김은대)   ->      공장1(김은대)
                                            ------->
-공장1(김은대)                          -----
ㄴ 공장1(홍길동)    ->  공장1(홍길동)----


이력서 지원 -> 평가
그 과정에서 신청 당시? 아니면 중간에 변화하는 것 반영?
지원했을 때 지원서 기록 테이블이 있어야 하나? - 입사지원서 이력관리 테이블
자기소개서 기록 테이블이 있어야 하나? - 자기소개서 이력관리 테이블



메뉴 - 권한
N   :   N
메뉴 - 메뉴별권한 - 권한

사용자 - 권한
N   :   N
사용자 - 사용자별권한 - 권한

Filter, Interceptor



성능, crud 관점으로 테이블 합치고 나누기

1:1인 건 합칠 수 있는지 확인해보기(합쳐야 할지 판단해볼...)

1:N 상태구분코드 같은 것들 -> 운영자 조정 가능, 회원들 조정 가능X / 쿼리짜기 힘들어짐, 그래서 쟤네 할 떈 사람들끼리 조정해야 함
=> 공통 코드 설계서 : 직급코드, 상태구분코드 같은 것들 다 한 테이블에 만들기
master성(고유 속성이 있는 것들은 따로 만들어야 함) => 따로 테이블 만듬(부서 같은 것들)
국가코드 국가명,국가코드,남녀,예아니오,진행상태 => 그냥 하나의 테이블로 만듬 => 대분류, 소분류 나눔

    001 : 회원상태구분 코드
    001 01 정회원
    001 02 휴직
    001 03 퇴사
    => 이런 것들 한 번에 할 수 있는 화면 하나만 있으면 됨


다운로드 말고는 그냥 썸네일처럼 줄여서 보여줘라~ 그럼 성능 나아짐
자바 섬네일, jsp섬네일

캐쉬활용, 특정 시간이 지나면 바뀌게
정적 데이터가 항상 동일하다면 캐쉬 쓰기

오류 코드 페이지 -> web.xml 설정(java config로 하면 java에서 함)
오류 코드, Exception


레이어팝업 : 어떤 과정 진행하다가 멈춰야 할 때 씀 / 작업처리를 볼 수 없음
윈도우팝업 : 옵셔널하게 쓰는 경우가 많음(그냥 선택하게 함) / 메인화면 작업하면서 윈도우팝업에서 데이터 갖다 쓰기 가능
레이어팝업+윈도우팝업 : 다이얼로그
둘 다 쓸 줄 알아야 함
ex)
목록 -> 상세페이지
전환되는 화면도!, 새창이 뜨게끔도!
메뉴에 팝업여부 주기

채팅창 - 작업을 하면서 채팅하고 싶음....-> 메뉴에 있으면 안 됨
메뉴 만들 때 부가적인 건 공통 팝업으로 빼는 것이 좋음
메뉴는 업무에 관한 부분
부가는 ~~~

페이징 -> 쿼리 자체를 특정 구간으로 조회
필터 기능으로 처리는 안 됨...
페이지 위에 엑셀 다운로드 버튼을 만들었으면 좋겠음
엑셀에서 그 페이지만 보는 게 아니고 전체 페이지를 봤으면 좋겠음

너무 큰 거...
병렬화한 걸 직렬화로
시간이 소요될 수 있음을 보여주기
스레드 사용


화면 구성의 통일성
항목은 항상 꽉 채워서 보여줘야 함
뭐가 부족하면 뭐라도 채워줘야 함
해상도 기준
브라우저 호환성 검사

업무성 화면(업무 빨리 효율) -> 가급적 많은 데이터를 보여주기(버튼위치 통일성) - 그리드, 탭
- 검토페이지
대민성 화면(이쁘고 정확) -> 가급적 이쁘게 보여주기 - 스크롤, 탭
- 메인페이지


역정규화 -> 데이터를 중복해서 쓰겠다.

트리거..FileController

컨트롤러(안내데스크지 다른 업무는 서비스가.., 내외부커넥션, 서비스한테 일 넘기고, 결과 받기) - 간단간단해야 함
- 파라미터 수집(조회) - 외부 파라미터, 세션 자료 조회
- 파라미터 검증(validation 보안에 대한 검증, 시스템 오류 안 나게끔 하는 검증)
  - 사용자 너 맞아? 지금 세션에 맞는 것과 일치하니? 회사가 일치하니?
  - 들어오는 파라미터 다 검증하라는 게 아님
  - input[hidden]이 아닌 건 사용자가 알아서 써라~~
  - input[hidden]인 건 반드시 체크해야 함!(반드시 검사해야 할 항목이라면)
  - 그 가격이 맞는지, 그 할인률을 적용시킬 수 있는 조건의 사람인지, 할인쿠폰을 쓸 수 있는 사람인지
- 서비스 호출
- 결과자료 저장
- 화면방출


컨트롤러
- 파라미터 수집(조회)
- 파라미터 검증
- 서비스 마스터 정보 저장
- 서비스 파일목록 저장
- 결과자료 저장
- 화면 방출
=> 문제의 소지가 있음 : 트랜잭션 문제-> 마스터 정보 저장(insert) 파일목록에서 에러나면 파일은 안 되고 마스터 정보만 입력됨..
=> 그래서 트랜잭션, 업무의 단위는 서비스 단위로 함
=> 디비 커넥션이 다르다면 괜찮음

- 서비스 마스터 정보 저장
- 서비스 파일목록 저장
=> 
- 서비스 호출(서비스가 서비스를 호출할 수 있음)
    - 마스터 정보 저장(마스터 정보 저장하는 서비스)
    - 파일목록 저장(파일 정보 저장하는 서비스)
=> 디비 커넥션이 계속 유지돼야 함.

transaction propagation
required

왜 이걸 선택했는가를 생각해봐야 함
====================================================================================
CBD 개발방법론
-Component Based Development

유즈케이스다이어그램은 고객이 보는 것 -> 동그라미 세분화 x(회원관리-회원등록, 회원수정, 회원삭제)
하나의 crud는 하나의 유즈케이스로 만든다.
명세서는 누구는 수정할 수 있고, 누구는 삭제할 수 있고 이런 세분화

ERD, 화면설계서 중요
=====================================================================================
2.4
예외처리
        
IO : FileReader, FileInputStream 
BufferedReader, BufferedWriter => IO객체 아님, IO의 속도를 빠르게 해주기 위해서 만든 보조 클래스

1.클래스명 지정, 경로 생성
2.파일 읽기 -> read()
3.변환
4.쓰기작업 -> write()
```
//template.txt먼저 만들고 시작
public class ${className} {
    public static void main(string[] args) throws Exception {
        String className = "Test02_예외";
        String path = "src/Test/java01/test01/" + className + ".java";
        StringBuffer sb = readTeamplate();

        String replace = sb.toString().replace("${className}", className);

        writeTemplate(replace, path); 
    }

    public static StringBuffer readTemplate() throws Exception { // 읽기
        // String read = ""; // String은 많이 느림
        StringBuffer read = new StringBuffer();

        BufferedReader br = new BufferedReader(new FileReader("srec/test/java01/test01/template.java"))
        while(true) {
            String readLine = br.readLine();
            if (readLine == null) { break; } // 단일블록이라도 확인해주세요
            System.out.println(readLine); // sysout 쓰지 마세요..
            if (read.length() == 0) {
                read.appen(readLine);
            } else {
                read.append("\r\n" + readLine);
            }
        }
        br.close();

        return read;
    }

    private static void writeTemplate(String replace, String path) { // 쓰기
        BufferedWriter bw = new BufferedWriter(new FileWriter(path));
        bw.write(replace);
        bw.close();
    }
}
```
==========================================================================================
모든 프로그램은 다음과 같은 과정을 거친다.
1. 객체 생성
2. 작업
3. 종료
   
   예외처리
```
    public static StringBuffer readTemplate() {
        // 1. 객체 생성
        BufferedReader br = new BufferedReader(new FileReader("srec/test/java01/test01/template.java")) => try/catch
        // 2. 작업
        while(true) {
            String readLine = br.readLine(); => try/catch
            if (readLine == null) { break; } // 단일블록이라도 확인해주세요
            System.out.println(readLine); // sysout 쓰지 마세요..
            if (read.length() == 0) {
                read.appen(readLine);
            } else {
                read.append("\r\n" + readLine);
            }
        }
        // 3. 종료
        br.close(); => try/catch
    }
```
```
    public static StringBuffer readTemplate() {
        // 1. 객체 생성
        BufferedReader br = null;
        // 2. 작업
        try {
            br = new BufferedReader(new FileReader("srec/test/java01/test01/template.java")); => try/catch
            while(true) {
                String readLine = br.readLine(); => try/catch
                if (readLine == null) { break; } // 단일블록이라도 확인해주세요
                System.out.println(readLine); // sysout 쓰지 마세요..
                if (read.length() == 0) {
                    read.appen(readLine);
                } else {
                    read.append("\r\n" + readLine);
                }
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                
            }

            try {
                if (br != null) {
                    br.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
```
=> try/catch에서 try에 다 넣거나, 한 개씩 처리하거나...등등
...오류가 나면 어떻게 하겠다!!!라는 것이 다 다름
위에 걸로 따지면,
1) 읽거나
2) 읽다가 오류 나면 빠지거나
3) 못 불러와도 읽거나
4) 못 읽으면 종료 안 하거나
5) ....
뭐가 많음...
* 반드시 선행해야 할 로직이 있다면 try/catch를 같이 묶어줌.
ex) 읽기 객체 생성 - 읽기 작업 - 종료 => 생성, 작업은 같이 있어야 함.. 종료는 따로 있어야 함
    생성과 작업은 한 쌍(하나의 트랜잭션 단위), 중간에 읽다가 오류가 나더라도 종료는 시켜야 함!
    선언만하고 초기화 안 한 것도 문제가 있음

작업마다 특성이 다 다름. 그 특성에 맞게 try/catch해야 함
try/catch 안에 try/catch를 하거나, try/catch 후 try/catch를 해야 하거나 등등
catch에 대해 잘 이해한 해야 함.
catch 중요중요
***** finally는 중간에 뭐가 있어도 finally까지 처리하고 끝냄, 중간에 return이 있더라도!!!!

try with resources => try안에 ()를 열어서 객체를 넣으면 그 객체는 자동으로 종료 => finally(종료 작업만 있다면)가 필요 없어짐(종료 말고 다른 작업이 있다면 말이 달라짐)
객체가 같아도, 달라도 그 안에 여러 개 쓸 수 있음
()에 들어올 자격이 있는 녀석들이 있음. 그게 머냐!! implements에 Closeable인 것들~~ 

모듈 개발 시 사용하는 입장에서도 생각해봐야 함(모듈을 만든다는 의미 중 하나는, 특정한 메서드를 만드는 것 ex)StringBuffer를 반환해주는 read(String path) 등등)
====================================================================================================

domain은 사이즈가 있는 단어 기준
입사일자, 퇴사일자, 입사일시, 퇴사일시
일자 : 날짜 고려(date)
일시 : 시간 고려 (timestamp)
테이블이 다른 곳에서 같은 건 같은 용어로 씀. MEM_ID는 MEM_ID로 붙임. CART_MEMBER로 안 씀
여부
코드, 코드번호
- DA가 정함 보통
- 복합키 순서 중요 -> 나중에 찾을 때 속도 부분에서 이 순서가 중요함!!

======================================================================================================
exerd

용어사전

샘플 - 행정 표준 용어사전
erd와 연결 가능 -> 논리명 작성 시 자동으로 들어감(행정 표준 용어 사전 기준)
속도도 빨라지고 공통으로 사용 가능

공통코드
시스템이 제공해주는 데이터 -> 공통코드

==테이블==
공통코드그룹 - 
공통코드


메뉴 -> db화
권한에 따라 보여줘야 할 메뉴 달라져야 함

공통코드 - 권한코드 => 넣어도 됨, 하지만 권한은 선을 연결해야 할 것들이 있음(메뉴, 사용자 등)
공통코드 - 선 안 그음(시스템 사용하는 모든 코드 모아놓음)



=============================================================================================================
1. 각 항목 - 이력서 FK 주기 (이력서Master-항목Detail)
* Join 안 할 수 있는 방향으로
2. 이력서 부분 바뀔 수 있는 건 들어가야 함(이름, 생년월일, 전화번호, 이메일 등)
* 중복될 수도 있는 부분이지만 실제론 '당대성'을 갖는 이력서
* 생년월일 -> DATE말고 VARCHAR2
* formatting(날짜 등) => 전부 동일하게 하기 -, ., /, 등등 => 데이터 자체에는 굳이 안 넣음(생년월일, 전화번호 등)
* 