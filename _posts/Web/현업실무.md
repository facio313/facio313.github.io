1.19
Single Page Application
CSR(Client Side Render) > SSR(Server Side Render)

Controller Serivce Mapper SQL ajax

벨리온 소프트
1.28
DB설계
화면ui분석
현업vs학원 : 하고 싶은 주체가 다름 = 나 vs 발주자(외부요청)
외부요청의 특징적인 부분
- 화면 pdf 출력 가능하게 해주세요~(요구사항)
- 레드마인 실제로도 많이 씀
- 첨부파일 머라고 한 거임??
- 자바 심상원(대법원 인터넷 등기소 함 봐봐)

- 주민번호를 db에 그대로 담으면 안 됨(암호화해서 담아야 함)
- 개인정보보호법 관련
- 재동의 받는 것(로그인할 때 받는 것 -> 안 받으면 어쩔 거냐..동의 기간 지나면 막아야 함)
- 휴면계쩡(sql스케쥴러, framework스케쥴러)

생각한 기능을 구체화하는 게 어렵다
db설계

정처기 공부해라..
세션 클러스터링
라운드 로빈 스케쥴링 알고리즘

os 안에서 돌아가는 톰캣이 갖는 server.xml에 context path="/" "act"
톰캣에 돌아가는 project1, project2 이런 거 context라 함
context => container
project 간 session 공유가 됨 (이걸 세션 클러스터링) - context 이중화?
근데 os가 멈추면 톰캣도 멈추면서 procject가 멈춤...
이때 os를 두 개 만들고 각 os에 서버를 두고 각각 소스를 보냄(서버 이중화)
project가 근데 같은 곳을 바라봐야 함..
이중화 관련 문제가 있음

1. 겸손(계속 공부)
2. 자기가 못하는 거 열심히(못하는 거 피해가지 말고)
3. pl argu할 정도론 하지 마..
4. 자기의 메인 기능이 먼지
5. 자기가 하고 싶은거 뭔지
6. 뭐에서 pl 말을 들어야 한다고?...
7. 팀끼리 공유, 경쟁

db는 사람마다, 선생님마다 다름
- 내꺼가 틀렸단 생각 말고, 남의 것도 틀렸단 생각 말기
- 화면 만드는 데에 지장이 없는지만 생각하기
- 물어봤는데 답변을 못하고, 화면상 정의하지 못한 건 틀린 것

inner join의 기줌
화살표의 종착지가 어디냐에 따라 다름
lprod(a개) prod(b개) buyprod
        cart(c개)   member(b개)
lprod -< prod

outer join
- left
- right
각 기준으로 데이터가 몇 개 나오나

T1      T2
1       10
2       2
3       1
4       0
5       0
inner join 13개
outer join
- left : 15개
- right : 13개
ansi outer join


* right는 속도 문제 있음 -> inner join 쓰세요~

---|-----oK--- 의미
   1      N


테이블마다 동일한 건 동일하게 이름을 검 -> 그래서 원래는 별칭을 줘야 함
select b.prod_id, b.prod_name, a.cart_qty, (b.prod_price * a.cart_qty) as sum_
from cart a, prod b
where a.cart_prod = b.prod_id

cart a inner join prod b on (a.cart_prod = b.prod_id)

기준관리 테이블 : prod 계속 현행화되는 데이터(데이터 시점 : 현재)
이력관리 테이블 : cart 데이터가 계속 생성되는 것(데이터 시점 : 당시)

cart_price가 있어야 함

prod_price 현재의 가격
cart_price 판매 당시의 가격

    민원신청        ->      검토            ->      완료저장소(대장)
-공장1(김은대)      ->      공장1(김은대)   ->      공장1(김은대)
                                            ------->
-공장1(김은대)                          -----
ㄴ 공장1(홍길동)    ->  공장1(홍길동)----


이력서 지원 -> 평가
그 과정에서 신청 당시? 아니면 중간에 변화하는 것 반영?
지원했을 때 지원서 기록 테이블이 있어야 하나? - 입사지원서 이력관리 테이블
자기소개서 기록 테이블이 있어야 하나? - 자기소개서 이력관리 테이블



메뉴 - 권한
N   :   N
메뉴 - 메뉴별권한 - 권한

사용자 - 권한
N   :   N
사용자 - 사용자별권한 - 권한

Filter, Interceptor



성능, crud 관점으로 테이블 합치고 나누기

1:1인 건 합칠 수 있는지 확인해보기(합쳐야 할지 판단해볼...)

1:N 상태구분코드 같은 것들 -> 운영자 조정 가능, 회원들 조정 가능X / 쿼리짜기 힘들어짐, 그래서 쟤네 할 떈 사람들끼리 조정해야 함
=> 공통 코드 설계서 : 직급코드, 상태구분코드 같은 것들 다 한 테이블에 만들기
master성(고유 속성이 있는 것들은 따로 만들어야 함) => 따로 테이블 만듬(부서 같은 것들)
국가코드 국가명,국가코드,남녀,예아니오,진행상태 => 그냥 하나의 테이블로 만듬 => 대분류, 소분류 나눔

    001 : 회원상태구분 코드
    001 01 정회원
    001 02 휴직
    001 03 퇴사
    => 이런 것들 한 번에 할 수 있는 화면 하나만 있으면 됨


다운로드 말고는 그냥 썸네일처럼 줄여서 보여줘라~ 그럼 성능 나아짐
자바 섬네일, jsp섬네일

캐쉬활용, 특정 시간이 지나면 바뀌게
정적 데이터가 항상 동일하다면 캐쉬 쓰기

오류 코드 페이지 -> web.xml 설정(java config로 하면 java에서 함)
오류 코드, Exception


레이어팝업 : 어떤 과정 진행하다가 멈춰야 할 때 씀 / 작업처리를 볼 수 없음
윈도우팝업 : 옵셔널하게 쓰는 경우가 많음(그냥 선택하게 함) / 메인화면 작업하면서 윈도우팝업에서 데이터 갖다 쓰기 가능
레이어팝업+윈도우팝업 : 다이얼로그
둘 다 쓸 줄 알아야 함
ex)
목록 -> 상세페이지
전환되는 화면도!, 새창이 뜨게끔도!
메뉴에 팝업여부 주기

채팅창 - 작업을 하면서 채팅하고 싶음....-> 메뉴에 있으면 안 됨
메뉴 만들 때 부가적인 건 공통 팝업으로 빼는 것이 좋음
메뉴는 업무에 관한 부분
부가는 ~~~

페이징 -> 쿼리 자체를 특정 구간으로 조회
필터 기능으로 처리는 안 됨...
페이지 위에 엑셀 다운로드 버튼을 만들었으면 좋겠음
엑셀에서 그 페이지만 보는 게 아니고 전체 페이지를 봤으면 좋겠음

너무 큰 거...
병렬화한 걸 직렬화로
시간이 소요될 수 있음을 보여주기
스레드 사용


화면 구성의 통일성
항목은 항상 꽉 채워서 보여줘야 함
뭐가 부족하면 뭐라도 채워줘야 함
해상도 기준
브라우저 호환성 검사

업무성 화면(업무 빨리 효율) -> 가급적 많은 데이터를 보여주기(버튼위치 통일성) - 그리드, 탭
- 검토페이지
대민성 화면(이쁘고 정확) -> 가급적 이쁘게 보여주기 - 스크롤, 탭
- 메인페이지


역정규화 -> 데이터를 중복해서 쓰겠다.

트리거..FileController

컨트롤러(안내데스크지 다른 업무는 서비스가.., 내외부커넥션, 서비스한테 일 넘기고, 결과 받기) - 간단간단해야 함
- 파라미터 수집(조회) - 외부 파라미터, 세션 자료 조회
- 파라미터 검증(validation 보안에 대한 검증, 시스템 오류 안 나게끔 하는 검증)
  - 사용자 너 맞아? 지금 세션에 맞는 것과 일치하니? 회사가 일치하니?
  - 들어오는 파라미터 다 검증하라는 게 아님
  - input[hidden]이 아닌 건 사용자가 알아서 써라~~
  - input[hidden]인 건 반드시 체크해야 함!(반드시 검사해야 할 항목이라면)
  - 그 가격이 맞는지, 그 할인률을 적용시킬 수 있는 조건의 사람인지, 할인쿠폰을 쓸 수 있는 사람인지
- 서비스 호출
- 결과자료 저장
- 화면방출


컨트롤러
- 파라미터 수집(조회)
- 파라미터 검증
- 서비스 마스터 정보 저장
- 서비스 파일목록 저장
- 결과자료 저장
- 화면 방출
=> 문제의 소지가 있음 : 트랜잭션 문제-> 마스터 정보 저장(insert) 파일목록에서 에러나면 파일은 안 되고 마스터 정보만 입력됨..
=> 그래서 트랜잭션, 업무의 단위는 서비스 단위로 함
=> 디비 커넥션이 다르다면 괜찮음

- 서비스 마스터 정보 저장
- 서비스 파일목록 저장
=> 
- 서비스 호출(서비스가 서비스를 호출할 수 있음)
    - 마스터 정보 저장(마스터 정보 저장하는 서비스)
    - 파일목록 저장(파일 정보 저장하는 서비스)
=> 디비 커넥션이 계속 유지돼야 함.

transaction propagation
required

왜 이걸 선택했는가를 생각해봐야 함
====================================================================================
CBD 개발방법론
-Component Based Development

유즈케이스다이어그램은 고객이 보는 것 -> 동그라미 세분화 x(회원관리-회원등록, 회원수정, 회원삭제)
하나의 crud는 하나의 유즈케이스로 만든다.
명세서는 누구는 수정할 수 있고, 누구는 삭제할 수 있고 이런 세분화

ERD, 화면설계서 중요
=====================================================================================
2.4
예외처리
        
IO : FileReader, FileInputStream 
BufferedReader, BufferedWriter => IO객체 아님, IO의 속도를 빠르게 해주기 위해서 만든 보조 클래스

1.클래스명 지정, 경로 생성
2.파일 읽기 -> read()
3.변환
4.쓰기작업 -> write()
```
//template.txt먼저 만들고 시작
public class ${className} {
    public static void main(string[] args) throws Exception {
        String className = "Test02_예외";
        String path = "src/Test/java01/test01/" + className + ".java";
        StringBuffer sb = readTeamplate();

        String replace = sb.toString().replace("${className}", className);

        writeTemplate(replace, path); 
    }

    public static StringBuffer readTemplate() throws Exception { // 읽기
        // String read = ""; // String은 많이 느림
        StringBuffer read = new StringBuffer();

        BufferedReader br = new BufferedReader(new FileReader("srec/test/java01/test01/template.java"))
        while(true) {
            String readLine = br.readLine();
            if (readLine == null) { break; } // 단일블록이라도 확인해주세요
            System.out.println(readLine); // sysout 쓰지 마세요..
            if (read.length() == 0) {
                read.appen(readLine);
            } else {
                read.append("\r\n" + readLine);
            }
        }
        br.close();

        return read;
    }

    private static void writeTemplate(String replace, String path) { // 쓰기
        BufferedWriter bw = new BufferedWriter(new FileWriter(path));
        bw.write(replace);
        bw.close();
    }
}
```
==========================================================================================
모든 프로그램은 다음과 같은 과정을 거친다.
1. 객체 생성
2. 작업
3. 종료
   
   예외처리
```
    public static StringBuffer readTemplate() {
        // 1. 객체 생성
        BufferedReader br = new BufferedReader(new FileReader("srec/test/java01/test01/template.java")) => try/catch
        // 2. 작업
        while(true) {
            String readLine = br.readLine(); => try/catch
            if (readLine == null) { break; } // 단일블록이라도 확인해주세요
            System.out.println(readLine); // sysout 쓰지 마세요..
            if (read.length() == 0) {
                read.appen(readLine);
            } else {
                read.append("\r\n" + readLine);
            }
        }
        // 3. 종료
        br.close(); => try/catch
    }
```
```
    public static StringBuffer readTemplate() {
        // 1. 객체 생성
        BufferedReader br = null;
        // 2. 작업
        try {
            br = new BufferedReader(new FileReader("srec/test/java01/test01/template.java")); => try/catch
            while(true) {
                String readLine = br.readLine(); => try/catch
                if (readLine == null) { break; } // 단일블록이라도 확인해주세요
                System.out.println(readLine); // sysout 쓰지 마세요..
                if (read.length() == 0) {
                    read.appen(readLine);
                } else {
                    read.append("\r\n" + readLine);
                }
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                
            }

            try {
                if (br != null) {
                    br.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
```
=> try/catch에서 try에 다 넣거나, 한 개씩 처리하거나...등등
...오류가 나면 어떻게 하겠다!!!라는 것이 다 다름
위에 걸로 따지면,
1) 읽거나
2) 읽다가 오류 나면 빠지거나
3) 못 불러와도 읽거나
4) 못 읽으면 종료 안 하거나
5) ....
뭐가 많음...
* 반드시 선행해야 할 로직이 있다면 try/catch를 같이 묶어줌.
ex) 읽기 객체 생성 - 읽기 작업 - 종료 => 생성, 작업은 같이 있어야 함.. 종료는 따로 있어야 함
    생성과 작업은 한 쌍(하나의 트랜잭션 단위), 중간에 읽다가 오류가 나더라도 종료는 시켜야 함!
    선언만하고 초기화 안 한 것도 문제가 있음

작업마다 특성이 다 다름. 그 특성에 맞게 try/catch해야 함
try/catch 안에 try/catch를 하거나, try/catch 후 try/catch를 해야 하거나 등등
catch에 대해 잘 이해한 해야 함.
catch 중요중요
***** finally는 중간에 뭐가 있어도 finally까지 처리하고 끝냄, 중간에 return이 있더라도!!!!

try with resources => try안에 ()를 열어서 객체를 넣으면 그 객체는 자동으로 종료 => finally(종료 작업만 있다면)가 필요 없어짐(종료 말고 다른 작업이 있다면 말이 달라짐)
객체가 같아도, 달라도 그 안에 여러 개 쓸 수 있음
()에 들어올 자격이 있는 녀석들이 있음. 그게 머냐!! implements에 Closeable인 것들~~ 

모듈 개발 시 사용하는 입장에서도 생각해봐야 함(모듈을 만든다는 의미 중 하나는, 특정한 메서드를 만드는 것 ex)StringBuffer를 반환해주는 read(String path) 등등)
====================================================================================================

domain은 사이즈가 있는 단어 기준
입사일자, 퇴사일자, 입사일시, 퇴사일시
일자 : 날짜 고려(date)
일시 : 시간 고려 (timestamp)
테이블이 다른 곳에서 같은 건 같은 용어로 씀. MEM_ID는 MEM_ID로 붙임. CART_MEMBER로 안 씀
여부
코드, 코드번호
- DA가 정함 보통
- 복합키 순서 중요 -> 나중에 찾을 때 속도 부분에서 이 순서가 중요함!!

======================================================================================================
exerd

용어사전

샘플 - 행정 표준 용어사전
erd와 연결 가능 -> 논리명 작성 시 자동으로 들어감(행정 표준 용어 사전 기준)
속도도 빨라지고 공통으로 사용 가능

공통코드
시스템이 제공해주는 데이터 -> 공통코드

==테이블==
공통코드그룹 - 
공통코드


메뉴 -> db화
권한에 따라 보여줘야 할 메뉴 달라져야 함

공통코드 - 권한코드 => 넣어도 됨, 하지만 권한은 선을 연결해야 할 것들이 있음(메뉴, 사용자 등)
공통코드 - 선 안 그음(시스템 사용하는 모든 코드 모아놓음)



=============================================================================================================


1. 각 항목 - 이력서 FK 주기 (이력서Master-항목Detail)
* Join 안 할 수 있는 방향으로
2. 이력서 부분 바뀔 수 있는 건 들어가야 함(이름, 생년월일, 전화번호, 이메일 등)
* 중복될 수도 있는 부분이지만 실제론 '당대성'을 갖는 이력서
* 생년월일 -> DATE말고 VARCHAR2
* formatting(날짜 등) => 전부 동일하게 하기 -, ., /, 등등 => 데이터 자체에는 굳이 안 넣음(생년월일, 전화번호 등)
3. 이력서, 지원, 공고 등 우리가 갖고 있는 대부분의 테이블 PK는 일련번호일 가능성이 높음 (하루에 몇 개 들어오는지 생각해보고 다시 명시하기)
* PK 단어들
- ID : 사용자 입력이기 때문에 주로 크기나 패턴이 변동되는 것들
- 코드 : 정형화된 것들
- 번호 : 순차X 의미O
- 일련번호 : 순차O 의미는 딱히..(문서번호 ex)알파벳+년도+월+일+00001)
- 순번 : 잘 안 쓰고 복합키로 쓰는 편
4. 공고에서 담당자는 텍스트로 변경하는 것이 위험하지 않을 듯(기업회원 중 선택해도 상관 없음), 공고는 기업이 작성
5. 제목들의 크기가 다 너무 적음. Varchar2(1000)정도 괜찮음
6. 글상태 같은 것들 정확히 어떤 것인지 명시
7. 연봉, 급여는 어떤 형식으로 넣나? ex) 300~500, 300만원, 3,000,000 3000000 …
8. API를 사용하는 이유 : 데이터로 관리를 하지 않겠다.
9. 업종코드 등 API 끌어오되 가끔 DB를 갱신하는 것은 괜찮음, 근데 매번 끌어와서 DB에 저장 안 하고 보여주는 건 과부하
10. 고용형태, 상태, 분야, 분류, 구분 등 다 공통코드로 들어가야 함.
* 코드, 이름, 설명, 상위코드 정도만 들어가는 건 다 공통코드로 빼기
* 공통코드와 공통코드그룹으로만 해도 됨
* 따로 빼야 하는 코드는 추가적으로 무언가가 들어가야 한다면 그런 것임
11. 운영자, 회원 테이블 분리(회원이랑 운영자는 아예 다름)
12. 회원 ID는 회원 테이블에서만 유효함 => 다른 테이블에 들어갈 때는 작성자ID, 지원자ID 등으로
13. 오늘 본 인재 -> 24시간만 유효 => Batch 돌리기
14. 상태, 구분, 분류, 분야는 무슨 분류고 무슨 분야인지 구체적으로 적어주기
15. 커뮤니티 주제, 직무는 공통코드
16. 게시판이라는 이름을 구체화할 필요가 있음
17. NUMBER로 주면 길이 제한이 없음. NUMBER(5)으로 주면 5자리만 가능함. 딱히 제한할 거 없으면 그냥 NUMBER로 주기
18. 댓글 총 개수 -> 없애는 게 나을 듯함. 매번 UPDATE해줘야 하는데, 그냥 SELECT해서 SUM하는 게 나아보임
19. 문의하기 - 부모글 -> 덧글처럼 하는 게 나음. => 문의내역 - 답변내역
20. 구할 수 있는 데이터는 정확한 데이터여야 함. 총합 같은 유도 컬럼을 굳이 냅둬야 하나? 유도컬럼은 1차적으로 만들지 않음


=============================================================================================================

- 권한은 무조건 테이블로 빼라 : 한 명이 여러 권한 가질 수 있음
- 첨부파일 아이디 : 첨부파일 정보가 각각의 테이블에 있는 것이 직관적,INSERT하고 AJAX로 키값만 보내면 됨?
- 공통코드 : 회원 권한(사용자별, 메뉴별), 타입 등
- 품목,속성,단가,부서 등 특정 속성 관리 → 기준관리 테이블 (테이블로 따로 뺌)
- 코드성 데이터(콤보박스) → 변동사항 없으면 공통으로 뺀다
- 통계낼 수 있는 것들 코드화(텍스트 지양)
- 고용형태 - 기업코드랑 같이 연결 할 수 있음
- 날짜는 일자나 일시로, 글 상태는 공고상태 등으로 명명하기 (EX)작성일자)
- 수습기간은 수습기간일수 혹은 월수, 연봉급여는 연봉급여액 혹은 금액으로 명명
- 우대사항 4000바이트, 모집분야(담당업무내용),근무부서 크기 키우기


- 채용과정 분류코드 일대다
ㄴ OK
- 채용과정양식 잘못됨
ㄴ OK(일대다로 변경)
- 일대일은 항상 합쳐도 되는지 고민하기
ㄴ OK
- 채용과정항목,항목코드 밑에도 1대N
ㄴ OK
- 이력서 사용여부
- 이력서 제출하면 받은 쪽에서 이력서번호 물고 있으면 안됨. 이력당시 데이터 고정되어야 함
- 그 때 당시 이력서를 첨부파일로(더 사용하지 않으면) 혹은 테이블로 따로 빼기
- 첨부파일형태로 같이 보여줘
ㄴ  지원에다가 첨부파일로 pdf 넣기
- 이력서 세부에 정확한 구분자 필요
ㄴ OK
- 순서 일련번호가 아니라 학력.. 조회순번필요 컬럼 바꿔라
ㄴ X
- 학력 선별할 것 아니면 테이블로 따로 빠져야 함
ㄴ ?
- 카테고리 구분코드
- 기능종류 코드화, 공통코드
ㄴ 공통코드로 넣기
- 훈련기간은 훈련기간수나 시작,종료일자로 명명
- 교육기관_개월수 등으로 이름 명확히 하기
ㄴ SELECT박스-ENUM으로 고정 예정
- 이력서와 지원은 1:1관계 아님
ㄴ ? 1:N 맞는데?
- 이력서 일련번호와 이력서ID 논리명 일치시키기
ㄴ ? 돼있는 거 아닌가? 내가 바꾼 거 아닌가?
- 자기소개서랑 이력서도 1:N, 보통 만든걸 준다.
ㄴ X 이력서에 자기소개서 안 들어감
- 끌고와서 고쳐쓸 수도 있음
ㄴ X ERD 아니고 기능부분
- 추가항목같은거 일보러 제한할거 아니면 4000정도 보통 한다
ㄴ X 점수 넣는 테이블이라 상관 없다
- 1:1관계 ERD 다 틀렸다
ㄴ 선생님이 해준 건데...
- 정규화될수록 성능 낮아지고 관리포인트도 낮아짐
ㄴ X 점수 산출해서 매칭 돌려야 할 때 쓸 거라 1:1 해야됨
- 자기소개서 등 항목은 동적으로, 항목코드-점수로 컬럼화
ㄴ X 시스템 목적에 위배, 추가항목 있음
- 코드값 안 넣고 해도 됨. 항목 이름으로
ㄴ ?
- 입사지원점수 토론면접점수 자기소개 실무면접점수 등 다 합쳐도 됨(UI로 보여줄 때만 구분하면 되므로)
ㄴ X 나중에 매칭에 써야 하므로 안 합침



- 일반회원 복합키로 다 들어감 (EX)나의 12345) 혹은 일련번호 + 회원ID
- 일반회원에 INDEX로 만들어 생성하는게 좋음
- 일련번호X. 순서 뒤바꿔놓고 순번으로 관리. 어차피 중복관리 안 일어남.
- 시퀀스 남발하고 있음
- 공통코드에는 조회순번 있어야 함
- 나중에 추가한 항목이 중간에 보여야 할 수도 있으므로?
- 코드번호 개수 비고 카테고리 ⇒ 한 테이블로
- 투명도는 업체 정확한 기준 필요하며 명시해줄 것(가이드.. ~다를 수 있습니다. ~하고있으니 참고해주세요)
- 영업이익, 매출액 - 국세청
- 리뷰별점 우리꺼니까 ok
- 공고 조회수
- 가중치, 기준 명확하지 않으면 어렵다
- 설문 랭킹 이용할 수도 있음
- 매출액 가져 와서 연계 가져온 거에 의의 둬라..
- 연계데이터는 주기 있어야 함. 실시간, 하루에 한번 등
- 회사 1인평균급여금액 계속 update 되어야 함, 기준 있어야 함, 자동화

- 첨부파일번호 각 테이블로
- 리뷰 별점 등 1.5 등의 값 들어올 수 있음 →코드로 관리, 02는 별 반 개 등
- 공지사항,도움말 합쳐도 됨. 합칠 수 있는 테이블들 합쳐서 코드로 관리
  
==================================================================================================
2.18
Service로 가는 파라미터, DAO로 가는 파라미터 고정
중간에 AOP, 공통처리를 위해
Map을 많이 씀
List는 키값으로 찾을 수 없음
타입이 다 다르다면?? VO, DTO

Map<String, Object> map = new HashMap<>();
-> ParamMap map = ParampMap.init();
map.put("key", "value");
String val1 = map.getString(key);
Integer val2 = map.getInt(key);
StringBuffer sb = new StringBuffer();
sb.append("test");
map.put("key2", sb);
StringBuffer sb2 = map.get("key2", StringBuffer.class);