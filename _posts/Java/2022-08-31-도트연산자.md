---
layout: post
title: .(도트) 연산자
description: 자바에서 쓰이는 .(도트)! 갑툭튀로 나온 애를 설명도 않고 넘어간다? 있을 수 없지!
date: 2022-08-31 14:12:01
published: true
categories: Java
tags: [Java, 자바, ., 도트, 연산자]
---
  
# 그것도 이해 못하니?
아니 그럼 어쩌라는 거.. 책에 갑자기 Math.PI나오면서 그 다음 .이 뭘 의미하는지 얘기도 안 해주고 걍 넘어가버렸는데!!!라고 써놓고 분명 내가 안 듣고 졸았을 것이다. 요즘에는 Calendar now = Calendar.getInstance(); 이따구로 나오는데 그래 대충 알겠는데 Calendar.getInstance();는 뭐냐고 아오!! 지들 다 안다고 나한테 제대로 설명도 안 해줘 ㅜㅜㅜ 그것도 그렇고 최근에 이렇게 많이 쓰게 되니 무슨 의미인지 궁금도 하고 언제 어떻게 어디서 써야 하는지도 알아보기 위해 글을 쓴다
  
# 인터넷 검색 결과
1. 해당변수나 메소드에 접근할 때 사용
2. 인스턴스가 어떤 행동을 할 것인지 알려줌
3. 객체 접근 연산자

* 객체.객체변수
클래스가 있고, 클래스 내부에는 필드랑 메소드가 있다.
클래스를 통해 객체가 new 연산자를 통해 heap 영역에 만들어진다(이때, 객체는 클래스의 인스턴스).

    참조타입  참조변수  = new 생성자;
ex) Student  std   =  new Student();
- 참조타입은 Student라는 클래스
- 참조변수는 std인데 참조타입에 맞는 객체의 주소를 저장하는 변수
- 객체생성연산자 new는 heap 영역에 Student라는 객체를 생성함
- 그리고 해당 객체의 주소를 return하여 = 대입연산자를 통해 참조 변수에 저장함
- 클래스 파일에 있는 생성자 Student();

*Student가 생성자인가 메소드인가?
- 첫 글자가 대문자면 클래스, 소문자이면 메소드라고 생각하기

* 생성자
매개변수를 받아 객체의 필드값을 초기화하는 데 사용된다.
매개변수는 () 안에 들어가는 것들 생각하면 됨!
ex) laptop(String model, String color,...)
리턴타입 없고, 클래스명과 동일하게 만들어야 한다.
기본 생성자는 자동으로 생기고, 매개변수를 받아야 한다면 직접 작성해야 함
- 이때 매개변수를 다양하게 받으면 오버로딩이 필요함
ex) laptop(){} laptop(String model){} laptop(String model, String color){}
--> 다 비슷비슷한데?? {}안의 코드들이 중복됨. ==> this(객체 자기 자신을 의미)를 쓰게 됨

예시)
나중에 따로 다 찾아보기

메소드

 
에어컨을 사용하려면 에어컨 전원 버튼만 누르면 되지, 에어컨의 동작회로를 조작할 필요는 없다. 에어컨은 '전원을 누르는 행위' 만을 사용자에게 공개하고 동작 회로는 에어컨 안 쪽으로 숨겨 놓는다.
 
이처럼 객체는 자신의 모든 정보를 공개하지 않는다. 숨길 정보(private)는 숨기고 공개할 정보(public)만 공개한다. 우리가 객체에 접근하려면 객체 자체가 아닌 객체가 공개한 메소드를 통해 접근해야한다.
 
이때 메소드에 접근하는 연산자가 . 도트 연산자이다.
Airconditioner AC = new Airconditioner(); // 먼저 객체를 생성하고 AC.turnOn; // . 연산자로 메소드를 '호출'한다.
 
 
 
호출

 
우리는 메소드를 '호출'한다는 표현을 쓴다.
 
 
'호출'이라는 표현을
쓰는 이유는 무엇일까?
 
 
남북한이 대화를 위해 판문점에서 만나듯, 많은 객체들은 대화를 위해 main 스레드에서 만난다. 남북한의 '외교관'들이 판문점으로 불리어져 회담을 하는 것과 같이, 객체의 'public 메소드'들은 main 스레드에 '호출'되어 대화를 진행한다.
 
그래서 클래스는 두 가지 종류가 있다. 실행 클래스 그리고 라이브러리 클래스. 총 100개의 클래스가 있다고 한다면 99개가 라이브러리 클래스이고 1개가 실행클래스(Main 클래스)이다.
 

 
 
객체의 메소드는 Heap영역에 저장되지 않는다. Heap 영역에는 객체의 필드값이 저장된다. 스레드에서 메소드를 '. 도트 연산자'를 통해 호출하면 스레드 안에는 '프레임(frame)'이 형성된다.
 
프레임은 스레드 안에 스택 방식으로 적재된다. 그래서 스레드가 저장되는 메모리 영역을 STACK 영역이라 부른다. 적재되는 프레임들은 LIFO (Last In First Out) 방식으로 PUSH(생성) 와 POP(제거)이 이루어진다.
 
 

 
main 메소드에서 cal객체의 avg 메소드를 호출하면 메인 스레드에 avg 프레임이 적재된다.
 

avg 메소드가 프레임으로 적재되면 메소드의 코드를 실행하는데 그 안에 plus 메소드 호출이 존재한다. 그러면 메소드 영역에서 plus 메소드를 읽어와 avg 메소드 위에 적재시킨다.
 

 
plus 메소드를 읽어 메인 스레드에서 프레임을 실행시켜 결과값을 return한다. 결과 값을 리턴하면 plus 메소드의 프레임은 스레드 Stack에서 POP되어 사라지고 다시 그 밑에 있는 avg 메소드 프레임을 실행시킨다. return값을 sum변수에 저장시키고 연산하여 return 시킨다. 그러면 avg 메소드 프레임도 POP되어 스레드에서 제거된다.
 
결과값을 받은 main 스레드는 System.out.println()으로 결과값을 출력시키고 스레드를 종료시킨다. 이것이 메모리 영역에서 일어나는 객체의 생성과 호출의 대략적인 과정이다.
 
 
 

정리

 
 
1. new와 생성자를 통해 Heap 영역에 객체를 생성한다.
2. main 스레드에서 .연산자를 통한 메소드 호출로 Stack에 프레임을 구성한다.


https://hittheroadkr.blogspot.com/2017/03/dot.html
https://wikidocs.net/214
