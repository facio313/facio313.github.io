---
layout: post
title: 람다식
description: 코드를 좀 더 깔끔하게! 람다식을 알아보자
date: 2023-03-23
published: true
categories: Java
---
# 람다 표현식
함수형 프로그래밍의 함수식이며 자바 메서드를 간결한 함수식으로 표현한 것이다.
익명함수를 생성하기 위한 식. 자바에서는 '매개변수를 가진 코드 블럭' => 런타임 시 익명구현객체로 생성된다.

자바에서 메서드는 원래 클래스 안에서 정의된다. 하지만 람다식을 사용하면 메서드의 이름, 반환값 생략이 가능하고 변수에 넣을 수 있다. 이로 인해 코드가 매우 간결해진다.

메서드 타입, 이름, 매개변수 타입, 중괄호, return문을 생략하고 화살표를 넣는데, 이러한 특징 덕에 람다식을 익명함수라고도 한다. 객체 자리에 보통 들어가게 되는데 람다식은 원래 익명 객체인 것이다. 그래서 익명 클래스와 잘 어울린다. 익명 클래스 글을 참고하도록 하자.

## 표현방식
1. 매개변수의 '자료형이름'은 생략할 수 있다.
2. 매개변수가 1개일 경우에는 괄호'()'를 생략할 수 있다.
3. '실행문'이 1개일 경우에는 '{}'를 생략할 수 있다.
4. 매개변수가 하나도 없으면 괄호'()'를 생략할 수 없다.
5. 반환값이 있을 경우에는 return 명령을 사용한다.
6. 실행문에 return문만 있을 경우 return명령과 '{}'를 생략할 수 있다.

## 주의!
1. 람다식 내부에서 사용되는 지역변수 모두 final이어야 한다.(컴파일러가 자동으로 붙여줌)
2. 메서드 안에서 익명객체를 람다식으로 사용할 시 final로 안 만들고 싶으면 멤버변수, static으로 올리면 된다. 메서드 안에서만 문제가 됨.
3. 람다식을 쓴다는 것 = 익명객체를 쓴다는 것

```
int add(int x, int y) {
    return x + y;
}

// 컴파일러가 타입추론을 하므로 안 적어도 에러가 안 남(일정 자바 버전 이상에서만 가능)
(x, y) -> x + y;
```

컬렉션의 요소를 필터링, 매핑하듯 stream()을 이용할 떄 많이 사용된다.

# 자바스크립트의 화살표 함수와 차이
자바스크립트에서는 다음과 같은 '일급객체' 특징을 가진다.
1. 객체를 변수에 할당 가능하다.
2. 다른 함수를 인자로 전달 받는다.
3. 다른 함수의 결과로서 리턴될 수 있다.

자바에서는 일급객체가 안 되는데 이는 메서드가 클래스 안에서 정의되고 반드시 함수에 대한 타입이 선언되어야 하기 때문이다. 그래서 자바에서는 일급객체의 특징을 사용하지 못한다. 이를 어느 정도 상쇠하기 위해 람다식을 사용할 수 있다. 함수를 해당 인터페이스 타입으로 받을 수 있도록 설계한 것이다. 이것이 바로 함수형 인터페이스이다.

# 함수형 인터페이스
interface를 선언하고 그 위에 annotation으로 @functionalInterface를 적어주면 된다. 이 함수형 인터페이스는 단 한 가지의 메서드를 가진다는 특징이 있다. 그래서 람다식을 사용할 때 어떤 메서드를 부른 것인지 헷갈릴 필요가 없어진다. (왜냐하면 단 한 개만 존재하니까..)

일급객체처럼 사용하기 위해 Object 타입의 변수에 할당해보지만 Object에는 람다식 클래스에서 정의한 메서드가 존재하지 않기에 나중에 그 변수에 접근제어자를 사용하여 그 메서드를 사용할 수 없다. 이때 이 함수형 인터페이스 타입의 변수에 할당하게 되면, @Override해서 메서드를 정의한 다음 그 변수에 접근제어자를 사용하여 메서드를 사용할 수 있게 된다.

# Thread 
람다식은 Thread에서 많이 사용된다. Runnable 객체를 사용하기 때문인데 이는 Thread 글에서 참고바란다.

# Enum
람다식은 Enum에서 사용되면 간결하고 깔끔하게 열거형 클래스를 정의할 수 잇다.
```
enum Operation {
    PLUS("+", (x, y) -> x + y);

    private final String symbol;
    private final DoubleBinaryOperator op;

    Operation(String symbol, DoubleBinaryOperator op) {
        this.symbol = symbol;
        this.op = op;
    }

    @Override
    public String toString() { return symbol; }

    public double apply(double x, double y) {
        return op.applyAsDouble(x, y);
    }    
}
```

# 단점
1. 문서화 X
2. 디버깅 어려움
3. streamdㅔ서 람다 사용 시 for문보다 성능 떨어짐
4. 남발 시 지저분..
5. 재귀 시 부적합