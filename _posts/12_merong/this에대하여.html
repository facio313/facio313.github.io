<!DOCTYPE html>
<meta charset="UTF-8">
<body>
    <input type="button" mybutton value="눌러봥봥">
</body>
<script>

    // const mButton = document.querySelector("input"); 
    // const mButton = document.querySelector("input[type]"); 
    // const mButton = document.querySelector("[type]"); 
    // const mButton = document.querySelector("input[type=button]"); 
    // const mButton = document.querySelector("input[type=button][value=눌러봥봥]"); 
    // 아이디 줘도 되는데, 내 맘대로 암 거나 속성이름 주고 대괄호로 속성 받아오기
    // 요즘 사용되는 테크닉(아는 사람만 앎)
    const mButton = document.querySelector("[mybutton]"); 
    console.log(mButton);
    function f_ck2(p_arg1) {
        console.log("나 눌렀닝? " + p_arg1);
    }
    // mButton.addEventListener("click", f_ck2()); // 괄호 붙이는 건 함수 호출하는 것 - 버튼 안 눌러도 그냥 실행됨
    // mButton.addEventListener("click", f_ck2); // 함수명 갖고옴, 함수 이름을 FP(Function Pointer)라고 부름
    mButton.addEventListener("click", f_ck2.bind(document, "선민카드"));

    // bind는 내부적으로 함수를 복사해서 매개변수를 넣은 함수포인터를 되돌려줌
    // call과 문법이 같으니 헷갈리면 안 됨
    // 쉽게 call은 함수를 실행시켜주고, bind는 함수포인터를 리턴(아직 실행 안 됨)해준다고 기억

    // this(이것, 나) 헷깔림
    // 전역변수 선언은 window 객체의 속성을 선언하는 것과 같고
    // 함수선언은 window 객체의 메서드를 선언하는 것과 같음
    // 함수지향언어 같지만, 알고 보면 객체 지향 언어

/*
function f_ck() {
    console.log(this);
}
f_ck.call({name : "로젱"});
f_ck.call({name : "제닝", age : 26});
f_ck.call(document);
*/

function f_ck(p_arg1, p_arg2) {
    console.log(this);
    console.log(p_arg1, "           ", p_arg2);
}
// f_ck.call({name : "로젱"}, "매개변수1", "매개변수2");
// f_ck.call({name : "제닝", age : 26}, "매개변수 1개만");
// f_ck.call(document, "aaa", "bbb");

// apply는 call과 사용법이 똑같음, 단지 매개변수들을 배열에 담아서 한 번에 줘야 함, 둘 다 함수를 실행시킴
// f_ck.apply({name : "제닝", age : 26}, ["매개변수1", "매개변수2"]);

/*
let anotherObj = {name : "서빈"}; // 객체 1개 생성
anotherObj.method1 = f_ck; // 객체의 method1이 f_ck를 참조
anotherObj.method1(); // f_ck 호출
// 스크립트 개발자 커뮤니티에서 항의, this 거지 같당!, 머리 아프다, 네가 해봐라
// 그래서 출현, call, apply, bind(현재는 엄청 중요!), this를 제어!

/*
    var merong = "흥칫뿡";
    alert(window.merong);
    alert(merong);

function f_ck() {
    console.log(this);
    console.log(this.document);
}
console.log(window.f_ck); // 눈으로 확인
window.f_ck();
f_ck();
*/
</script>