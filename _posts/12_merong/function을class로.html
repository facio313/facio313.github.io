<!DOCTYPE html>
<meta charset="UTF-8">
<script>
// 자바스크립트에선 function 키워드가 자바의 class키워드 역할까지 같이..

function Member(name, age, merit) {
    this.name = name; // 속성
    this.age = age;
    this.merit = merit;

    /* 메서드를 여기에 선언하면 메모리 낭비가 생김(밑에 글 참조)
    this.getName = function() { // 메서드
        return this.name;
    }
    */

    return this; // 없어도 됨, 명시적 표현(function 키워드가 class의 의미)
}
// 메모리 절약을 위해, 메서드는 공유(속성도 해도 되지만 큰 의미 없음)
// prototype도 기억해놓기
Member.prototype.getName = function() {
    return this.name;
}
// 화살표 함수는 this에 대한 제약사항이 있음
// 밑에처럼 해서 콘솔로 찍어보면 windown객체가 뜸...화딱지남..
// Member.prototype.getAge = () => this.age; 
Member.prototype.getAge = function() {
    return this.age;
}


let chan = new Member("찬영", 30, "그렇게 늙음");
let daehyun = new Member("대현", 33, "그렇게 보임");
console.log(chan);
console.log(daehyun.getName());
console.log(daehyun.getAge());

// 처음 객체를 만들었을 때 매번 새로 만드니 너무 메모리를 많이 쓰게 됨
// 그래서 처음 객체의 주소만 참고하게 됨

// 위 chan과 daehyun은 속성 값도 다르고 허니 다른 메모리를 가짐
// 근데 function으로 보자면 getName()은 완전히 똑같음...따로 갖고 있는 거 비효율적임
// 메서드 같은 건 객체가 생성되면서 가지고 있을 필요가 없음
// 자바스크립에서 객체가 생성될 때 메서드가 같이 있는 걸 좋아하지 않음. 특히 브라우저(하나의 프로그램)에서 메모리를 더 차지하게 하는 걸 좋아하지 않음
// 그래서 자바스크립트에선 prototype에다 저장하면 메서드를 공유할 수 있도록 해놓음
// console.log로 객체를 보게 될 때 prototype을 볼 수 있음
// 자바는 JVM이 알아서 메서드 메모리에 메서드를 공유시켜줌(메모리 절약)
// 자바스크립트는 직접해줘야 함.
</script>